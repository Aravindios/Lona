// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                           = require("bs-platform/lib/js/list.js");
var Block                          = require("bs-platform/lib/js/block.js");
var LodashCamelcase                = require("lodash.camelcase");
var SwiftFormat$LonaCompilerCore   = require("./swiftFormat.bs.js");
var SwiftDocument$LonaCompilerCore = require("./swiftDocument.bs.js");

function toSwiftAST(colors, textStyles, rootLayer, logicRootNode) {
  var logicValueToSwiftAST = function (x) {
    if (typeof x === "number") {
      return /* Empty */0;
    } else if (x.tag) {
      return SwiftDocument$LonaCompilerCore.lonaValue(colors, textStyles, x[0]);
    } else {
      var node = x;
      if (typeof node === "number") {
        return /* SwiftIdentifier */Block.__(5, ["BadIdentifier"]);
      } else if (node.tag) {
        return /* SwiftIdentifier */Block.__(5, ["BadIdentifier"]);
      } else {
        var match = node[1];
        if (match) {
          var tail = match[1];
          switch (match[0]) {
            case "layers" : 
                if (tail) {
                  var tail$1 = tail[1];
                  var second = tail[0];
                  if (second === rootLayer[/* name */1]) {
                    return /* SwiftIdentifier */Block.__(5, [List.fold_left((function (a, b) {
                                      return a + ("." + LodashCamelcase(b));
                                    }), List.hd(tail$1), List.tl(tail$1))]);
                  } else {
                    return /* SwiftIdentifier */Block.__(5, [List.fold_left((function (a, b) {
                                      return a + ("." + LodashCamelcase(b));
                                    }), SwiftFormat$LonaCompilerCore.layerName(second), tail$1)]);
                  }
                } else {
                  return /* SwiftIdentifier */Block.__(5, ["BadIdentifier"]);
                }
                break;
            case "parameters" : 
                return /* SwiftIdentifier */Block.__(5, [List.hd(tail)]);
            default:
              return /* SwiftIdentifier */Block.__(5, ["BadIdentifier"]);
          }
        } else {
          return /* SwiftIdentifier */Block.__(5, ["BadIdentifier"]);
        }
      }
    }
  };
  var typeAnnotationDoc = function (param) {
    if (param.tag) {
      return /* TypeName */Block.__(0, [param[0]]);
    } else {
      var typeName = param[0];
      if (typeName === "Boolean") {
        return /* TypeName */Block.__(0, ["Bool"]);
      } else {
        return /* TypeName */Block.__(0, [typeName]);
      }
    }
  };
  var fromCmp = function (x) {
    switch (x) {
      case 0 : 
          return "==";
      case 1 : 
          return "!=";
      case 2 : 
          return ">";
      case 3 : 
          return ">=";
      case 4 : 
          return "<";
      case 5 : 
          return "<=";
      case 6 : 
          return "???";
      
    }
  };
  var unwrapBlock = function (node) {
    if (typeof node === "number") {
      return /* :: */[
              node,
              /* [] */0
            ];
    } else if (node.tag === 5) {
      return node[0];
    } else {
      return /* :: */[
              node,
              /* [] */0
            ];
    }
  };
  var inner = function (logicRootNode) {
    if (typeof logicRootNode === "number") {
      return /* Empty */0;
    } else {
      switch (logicRootNode.tag | 0) {
        case 0 : 
            return /* IfStatement */Block.__(11, [{
                        condition: /* BinaryExpression */Block.__(2, [{
                              left: logicValueToSwiftAST(logicRootNode[0]),
                              operator: fromCmp(logicRootNode[1]),
                              right: logicValueToSwiftAST(logicRootNode[2])
                            }]),
                        block: List.map(inner, unwrapBlock(logicRootNode[3]))
                      }]);
        case 1 : 
            return /* StatementListHelper */Block.__(18, [/* :: */[
                        /* LineComment */Block.__(15, ["TODO: IfExists"]),
                        /* :: */[
                          /* IfStatement */Block.__(11, [{
                                condition: /* LiteralExpression */Block.__(0, [/* Boolean */Block.__(0, [/* true */1])]),
                                block: List.map(inner, unwrapBlock(logicRootNode[1]))
                              }]),
                          /* [] */0
                        ]
                      ]]);
        case 2 : 
            var match = logicValueToSwiftAST(logicRootNode[1]);
            var match$1 = logicValueToSwiftAST(logicRootNode[0]);
            var exit = 0;
            if (typeof match === "number") {
              exit = 1;
            } else if (match.tag === 5) {
              var name = match[0];
              var exit$1 = 0;
              if (name.includes("margin") || name.includes("padding")) {
                return /* LineComment */Block.__(15, ["TODO: Margin & padding"]);
              } else if (name.includes("image")) {
                return /* LineComment */Block.__(15, ["TODO: Images"]);
              } else if (typeof match$1 === "number") {
                exit$1 = 2;
              } else if (match$1.tag) {
                exit$1 = 2;
              } else {
                var match$2 = match$1[0];
                if (typeof match$2 === "number") {
                  exit$1 = 2;
                } else if (match$2.tag) {
                  exit$1 = 2;
                } else if (name.endsWith("visible")) {
                  return /* BinaryExpression */Block.__(2, [{
                              left: /* SwiftIdentifier */Block.__(5, [name.replace("visible", "isHidden")]),
                              operator: "=",
                              right: /* LiteralExpression */Block.__(0, [/* Boolean */Block.__(0, [1 - match$2[0]])])
                            }]);
                } else {
                  exit$1 = 2;
                }
              }
              if (exit$1 === 2) {
                if (name.endsWith("textStyle")) {
                  return /* StatementListHelper */Block.__(18, [/* :: */[
                              /* BinaryExpression */Block.__(2, [{
                                    left: /* SwiftIdentifier */Block.__(5, [name.replace(".textStyle", "TextStyle")]),
                                    operator: "=",
                                    right: match$1
                                  }]),
                              /* :: */[
                                /* BinaryExpression */Block.__(2, [{
                                      left: /* SwiftIdentifier */Block.__(5, [name.replace(".textStyle", ".attributedText")]),
                                      operator: "=",
                                      right: /* MemberExpression */Block.__(1, [/* :: */[
                                            /* SwiftIdentifier */Block.__(5, [name.replace(".textStyle", "TextStyle")]),
                                            /* :: */[
                                              /* FunctionCallExpression */Block.__(14, [{
                                                    name: /* SwiftIdentifier */Block.__(5, ["apply"]),
                                                    arguments: /* :: */[
                                                      /* FunctionCallArgument */Block.__(13, [{
                                                            name: /* Some */[/* SwiftIdentifier */Block.__(5, ["to"])],
                                                            value: /* SwiftIdentifier */Block.__(5, [name.replace(".textStyle", ".text ?? \"\"")])
                                                          }]),
                                                      /* [] */0
                                                    ]
                                                  }]),
                                              /* [] */0
                                            ]
                                          ]])
                                    }]),
                                /* [] */0
                              ]
                            ]]);
                } else if (name.endsWith("text")) {
                  return /* BinaryExpression */Block.__(2, [{
                              left: /* SwiftIdentifier */Block.__(5, [name.replace(".text", ".attributedText")]),
                              operator: "=",
                              right: /* MemberExpression */Block.__(1, [/* :: */[
                                    /* SwiftIdentifier */Block.__(5, [name.replace(".text", "TextStyle")]),
                                    /* :: */[
                                      /* FunctionCallExpression */Block.__(14, [{
                                            name: /* SwiftIdentifier */Block.__(5, ["apply"]),
                                            arguments: /* :: */[
                                              /* FunctionCallArgument */Block.__(13, [{
                                                    name: /* Some */[/* SwiftIdentifier */Block.__(5, ["to"])],
                                                    value: match$1
                                                  }]),
                                              /* [] */0
                                            ]
                                          }]),
                                      /* [] */0
                                    ]
                                  ]])
                            }]);
                } else if (name.endsWith("borderRadius")) {
                  return /* BinaryExpression */Block.__(2, [{
                              left: /* SwiftIdentifier */Block.__(5, [name.replace("borderRadius", "layer.cornerRadius")]),
                              operator: "=",
                              right: match$1
                            }]);
                } else if (name.endsWith("height")) {
                  return /* BinaryExpression */Block.__(2, [{
                              left: /* SwiftIdentifier */Block.__(5, [name.replace(".height", "HeightAnchorConstraint?.constant")]),
                              operator: "=",
                              right: match$1
                            }]);
                } else if (name.endsWith("width")) {
                  return /* BinaryExpression */Block.__(2, [{
                              left: /* SwiftIdentifier */Block.__(5, [name.replace(".width", "WidthAnchorConstraint?.constant")]),
                              operator: "=",
                              right: match$1
                            }]);
                } else {
                  exit = 1;
                }
              }
              
            } else {
              exit = 1;
            }
            if (exit === 1) {
              return /* BinaryExpression */Block.__(2, [{
                          left: match,
                          operator: "=",
                          right: match$1
                        }]);
            }
            break;
        case 3 : 
            return /* BinaryExpression */Block.__(2, [{
                        left: logicValueToSwiftAST(logicRootNode[2]),
                        operator: "=",
                        right: /* BinaryExpression */Block.__(2, [{
                              left: logicValueToSwiftAST(logicRootNode[0]),
                              operator: "+",
                              right: logicValueToSwiftAST(logicRootNode[1])
                            }])
                      }]);
        case 4 : 
            var value = logicRootNode[0];
            if (typeof value === "number") {
              return /* Empty */0;
            } else if (value.tag) {
              return /* Empty */0;
            } else {
              var path = value[1];
              return /* VariableDeclaration */Block.__(7, [{
                          modifiers: /* [] */0,
                          pattern: /* IdentifierPattern */Block.__(0, [{
                                identifier: List.fold_left((function (a, b) {
                                        return a + ("." + b);
                                      }), List.hd(path), List.tl(path)),
                                annotation: /* Some */[typeAnnotationDoc(value[0])]
                              }]),
                          init: /* None */0,
                          block: /* None */0
                        }]);
            }
            break;
        case 5 : 
            return /* StatementListHelper */Block.__(18, [List.map(inner, logicRootNode[0])]);
        
      }
    }
  };
  return List.map(inner, unwrapBlock(logicRootNode));
}

var Ast = 0;

var Format = 0;

var Document = 0;

exports.Ast        = Ast;
exports.Format     = Format;
exports.Document   = Document;
exports.toSwiftAST = toSwiftAST;
/* lodash.camelcase Not a pure module */
