// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var Block       = require("bs-platform/lib/js/block.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var Json_decode = require("bs-json/src/Json_decode.js");

function map(f, node) {
  if (typeof node === "number") {
    return Curry._1(f, node);
  } else {
    switch (node.tag | 0) {
      case 0 : 
          return Curry._1(f, /* Return */Block.__(0, [map(f, node[0])]));
      case 1 : 
      case 2 : 
          return Curry._1(f, node);
      case 3 : 
          var o = node[0];
          return Curry._1(f, /* ClassDeclaration */Block.__(3, [{
                          id: o.id,
                          superClass: o.superClass,
                          body: List.map((function (param) {
                                  return map(f, param);
                                }), o.body)
                        }]));
      case 4 : 
          var o$1 = node[0];
          return Curry._1(f, /* MethodDefinition */Block.__(4, [{
                          key: o$1.key,
                          value: map(f, o$1.value)
                        }]));
      case 5 : 
          var o$2 = node[0];
          return Curry._1(f, /* FunctionExpression */Block.__(5, [{
                          id: o$2.id,
                          params: o$2.params,
                          body: List.map((function (param) {
                                  return map(f, param);
                                }), o$2.body)
                        }]));
      case 6 : 
          var o$3 = node[0];
          return Curry._1(f, /* CallExpression */Block.__(6, [{
                          callee: map(f, o$3.callee),
                          arguments: List.map((function (param) {
                                  return map(f, param);
                                }), o$3.arguments)
                        }]));
      case 7 : 
          var o$4 = node[0];
          return Curry._1(f, /* JSXAttribute */Block.__(7, [{
                          name: o$4.name,
                          value: map(f, o$4.value)
                        }]));
      case 8 : 
          var o$5 = node[0];
          return Curry._1(f, /* JSXElement */Block.__(8, [{
                          tag: o$5.tag,
                          attributes: List.map((function (param) {
                                  return map(f, param);
                                }), o$5.attributes),
                          content: List.map((function (param) {
                                  return map(f, param);
                                }), o$5.content)
                        }]));
      case 9 : 
          return Curry._1(f, /* VariableDeclaration */Block.__(9, [map(f, node[0])]));
      case 10 : 
          var o$6 = node[0];
          return Curry._1(f, /* AssignmentExpression */Block.__(10, [{
                          left: map(f, o$6.left),
                          right: map(f, o$6.right)
                        }]));
      case 11 : 
          var o$7 = node[0];
          return Curry._1(f, /* BinaryExpression */Block.__(11, [{
                          left: map(f, o$7.left),
                          operator: o$7.operator,
                          right: map(f, o$7.right)
                        }]));
      case 12 : 
          var o$8 = node[0];
          return Curry._1(f, /* IfStatement */Block.__(12, [{
                          test: map(f, o$8.test),
                          consequent: List.map((function (param) {
                                  return map(f, param);
                                }), o$8.consequent)
                        }]));
      case 13 : 
          return Curry._1(f, /* ArrayLiteral */Block.__(13, [List.map((function (param) {
                                return map(f, param);
                              }), node[0])]));
      case 14 : 
          return Curry._1(f, /* ObjectLiteral */Block.__(14, [List.map((function (param) {
                                return map(f, param);
                              }), node[0])]));
      case 15 : 
          var o$9 = node[0];
          return Curry._1(f, /* Property */Block.__(15, [{
                          key: map(f, o$9.key),
                          value: map(f, o$9.value)
                        }]));
      case 16 : 
          return Curry._1(f, /* ExportDefaultDeclaration */Block.__(16, [map(f, node[0])]));
      case 17 : 
          return Curry._1(f, /* Block */Block.__(17, [List.map((function (param) {
                                return map(f, param);
                              }), node[0])]));
      case 18 : 
          return Curry._1(f, /* Program */Block.__(18, [List.map((function (param) {
                                return map(f, param);
                              }), node[0])]));
      case 19 : 
          var o$10 = node[0];
          return Curry._1(f, /* LineEndComment */Block.__(19, [{
                          comment: o$10.comment,
                          line: map(f, o$10.line)
                        }]));
      
    }
  }
}

function optimizeTruthyBinaryExpression(node) {
  var booleanValue = function (sub) {
    if (typeof sub === "number" || sub.tag !== 1) {
      return /* None */0;
    } else {
      return Json_decode.optional(Json_decode.bool, sub[0][/* data */1]);
    }
  };
  if (typeof node === "number") {
    return node;
  } else if (node.tag === 11) {
    var o = node[0];
    var match = booleanValue(o.left);
    var match$1 = o.operator;
    var match$2 = booleanValue(o.right);
    var exit = 0;
    if (match$1 !== 0) {
      return node;
    } else if (match$2) {
      if (match$2[0] !== 0) {
        return o.left;
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (match && match[0] !== 0) {
        return o.right;
      } else {
        return node;
      }
    }
    
  } else {
    return node;
  }
}

function renameIdentifiers(node) {
  if (typeof node === "number") {
    return node;
  } else if (node.tag === 2) {
    var match = node[0];
    if (match) {
      var tail = match[1];
      switch (match[0]) {
        case "layers" : 
            if (tail) {
              return /* Identifier */Block.__(2, [/* :: */[
                          List.fold_left((function (a, b) {
                                  return a + ("$" + b);
                                }), tail[0], tail[1]),
                          /* [] */0
                        ]]);
            } else {
              return node;
            }
        case "parameters" : 
            return /* Identifier */Block.__(2, [/* :: */[
                        "this",
                        /* :: */[
                          "props",
                          tail
                        ]
                      ]]);
        default:
          return node;
      }
    } else {
      return node;
    }
  } else {
    return node;
  }
}

function optimize(node) {
  return map(optimizeTruthyBinaryExpression, node);
}

function prepareForRender(node) {
  return map(renameIdentifiers, node);
}

exports.map                            = map;
exports.optimizeTruthyBinaryExpression = optimizeTruthyBinaryExpression;
exports.renameIdentifiers              = renameIdentifiers;
exports.optimize                       = optimize;
exports.prepareForRender               = prepareForRender;
/* No side effect */
