// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                           = require("bs-platform/lib/js/list.js");
var Block                          = require("bs-platform/lib/js/block.js");
var Curry                          = require("bs-platform/lib/js/curry.js");
var Caml_obj                       = require("bs-platform/lib/js/caml_obj.js");
var Pervasives                     = require("bs-platform/lib/js/pervasives.js");
var LodashUpperfirst               = require("lodash.upperfirst");
var Layer$LonaCompilerCore         = require("../core/layer.bs.js");
var Logic$LonaCompilerCore         = require("../core/logic.bs.js");
var Decode$LonaCompilerCore        = require("../core/decode.bs.js");
var LonaValue$LonaCompilerCore     = require("../core/lonaValue.bs.js");
var StringMap$LonaCompilerCore     = require("../containers/stringMap.bs.js");
var Constraint$LonaCompilerCore    = require("../utils/constraint.bs.js");
var SwiftLogic$LonaCompilerCore    = require("./swiftLogic.bs.js");
var SwiftFormat$LonaCompilerCore   = require("./swiftFormat.bs.js");
var SwiftDocument$LonaCompilerCore = require("./swiftDocument.bs.js");

function generate(_, swiftOptions, name, colors, textStyles, json) {
  var rootLayer = Decode$LonaCompilerCore.Component[/* rootLayer */1](json);
  var nonRootLayers = List.tl(Layer$LonaCompilerCore.flatten(rootLayer));
  var logic = Decode$LonaCompilerCore.Component[/* logic */2](json);
  var logic$1 = Logic$LonaCompilerCore.enforceSingleAssignment((function (_, path) {
          return /* :: */[
                  "_" + SwiftFormat$LonaCompilerCore.variableNameFromIdentifier(rootLayer[/* name */1], path),
                  /* [] */0
                ];
        }), (function (_, path) {
          return /* Literal */Block.__(1, [LonaValue$LonaCompilerCore.defaultValueForParameter(List.nth(path, 2))]);
        }), logic);
  var layerParameterAssignments = Layer$LonaCompilerCore.logicAssignmentsFromLayerParameters(rootLayer);
  var assignments = Layer$LonaCompilerCore.parameterAssignmentsFromLogic(rootLayer, logic$1);
  var parameters = Decode$LonaCompilerCore.Component[/* parameters */0](json);
  var priorityName = function (param) {
    if (param !== 0) {
      return "defaultLow";
    } else {
      return "required";
    }
  };
  var typeAnnotationDoc = function (param) {
    if (param.tag) {
      return /* TypeName */Block.__(0, [param[0]]);
    } else {
      var typeName = param[0];
      if (typeName === "Boolean") {
        return /* TypeName */Block.__(0, ["Bool"]);
      } else {
        return /* TypeName */Block.__(0, [typeName]);
      }
    }
  };
  var parameterVariableDoc = function (parameter) {
    return /* VariableDeclaration */Block.__(8, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PublicModifier */3]),
                  /* [] */0
                ],
                pattern: /* IdentifierPattern */Block.__(0, [{
                      identifier: /* SwiftIdentifier */Block.__(6, [parameter[/* name */0]]),
                      annotation: /* Some */[typeAnnotationDoc(parameter[/* ltype */1])]
                    }]),
                init: /* None */0,
                block: /* Some */[/* WillSetDidSetBlock */[{
                      willSet: /* None */0,
                      didSet: /* Some */[/* :: */[
                          /* FunctionCallExpression */Block.__(16, [{
                                name: /* SwiftIdentifier */Block.__(6, ["update"]),
                                arguments: /* [] */0
                              }]),
                          /* [] */0
                        ]]
                    }]]
              }]);
  };
  var getLayerTypeName = function (layerType) {
    var match = swiftOptions[/* framework */0];
    if (match !== 0) {
      switch (layerType) {
        case 0 : 
            return "NSBox";
        case 1 : 
            return "NSTextField";
        case 2 : 
            return "NSImageView";
        case 3 : 
        case 4 : 
        case 5 : 
        case 6 : 
            return "TypeUnknown";
        
      }
    } else {
      switch (layerType) {
        case 0 : 
            return "UIView";
        case 1 : 
            return "UILabel";
        case 2 : 
            return "UIImageView";
        case 3 : 
        case 4 : 
        case 5 : 
        case 6 : 
            return "TypeUnknown";
        
      }
    }
  };
  var getLayerInitCall = function (layerType) {
    var typeName = /* SwiftIdentifier */Block.__(6, [getLayerTypeName(layerType)]);
    var match = swiftOptions[/* framework */0];
    if (match !== 0) {
      if (layerType !== 1) {
        return /* FunctionCallExpression */Block.__(16, [{
                    name: typeName,
                    arguments: /* [] */0
                  }]);
      } else {
        return /* FunctionCallExpression */Block.__(16, [{
                    name: typeName,
                    arguments: /* :: */[
                      /* FunctionCallArgument */Block.__(15, [{
                            name: /* Some */[/* SwiftIdentifier */Block.__(6, ["labelWithString"])],
                            value: /* LiteralExpression */Block.__(0, [/* String */Block.__(3, [""])])
                          }]),
                      /* [] */0
                    ]
                  }]);
      }
    } else if (layerType !== 1) {
      if (layerType >= 3) {
        return /* FunctionCallExpression */Block.__(16, [{
                    name: typeName,
                    arguments: /* [] */0
                  }]);
      } else {
        return /* FunctionCallExpression */Block.__(16, [{
                    name: typeName,
                    arguments: /* :: */[
                      /* FunctionCallArgument */Block.__(15, [{
                            name: /* Some */[/* SwiftIdentifier */Block.__(6, ["frame"])],
                            value: /* SwiftIdentifier */Block.__(6, [".zero"])
                          }]),
                      /* [] */0
                    ]
                  }]);
      }
    } else {
      return /* FunctionCallExpression */Block.__(16, [{
                  name: typeName,
                  arguments: /* [] */0
                }]);
    }
  };
  var viewVariableDoc = function (layer) {
    return /* VariableDeclaration */Block.__(8, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                pattern: /* IdentifierPattern */Block.__(0, [{
                      identifier: /* SwiftIdentifier */Block.__(6, [SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1])]),
                      annotation: /* None */0
                    }]),
                init: /* Some */[getLayerInitCall(layer[/* typeName */0])],
                block: /* None */0
              }]);
  };
  var textStyleVariableDoc = function (layer) {
    return /* VariableDeclaration */Block.__(8, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                pattern: /* IdentifierPattern */Block.__(0, [{
                      identifier: /* SwiftIdentifier */Block.__(6, [SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + "TextStyle"]),
                      annotation: /* None */0
                    }]),
                init: /* Some */[/* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(6, ["TextStyles"]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(6, [textStyles[/* defaultStyle */1][/* id */0]]),
                          /* [] */0
                        ]
                      ]])],
                block: /* None */0
              }]);
  };
  var spacingVariableDoc = function (layer) {
    var variableName = function (variable) {
      var match = +(layer === rootLayer);
      if (match !== 0) {
        return variable;
      } else {
        return SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + LodashUpperfirst(variable);
      }
    };
    var match = +(layer === rootLayer);
    var marginVariables;
    if (match !== 0) {
      marginVariables = /* [] */0;
    } else {
      var createVariable = function (marginParameter) {
        return /* VariableDeclaration */Block.__(8, [{
                    modifiers: /* :: */[
                      /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                      /* [] */0
                    ],
                    pattern: /* IdentifierPattern */Block.__(0, [{
                          identifier: /* SwiftIdentifier */Block.__(6, [variableName(marginParameter[/* swiftName */1])]),
                          annotation: /* Some */[/* TypeName */Block.__(0, ["CGFloat"])]
                        }]),
                    init: /* Some */[/* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [Layer$LonaCompilerCore.getNumberParameter(marginParameter[/* lonaName */0], layer)])])],
                    block: /* None */0
                  }]);
      };
      marginVariables = List.map(createVariable, /* :: */[
            /* record */[
              /* lonaName */"marginTop",
              /* swiftName */"topMargin"
            ],
            /* :: */[
              /* record */[
                /* lonaName */"marginRight",
                /* swiftName */"trailingMargin"
              ],
              /* :: */[
                /* record */[
                  /* lonaName */"marginBottom",
                  /* swiftName */"bottomMargin"
                ],
                /* :: */[
                  /* record */[
                    /* lonaName */"marginLeft",
                    /* swiftName */"leadingMargin"
                  ],
                  /* [] */0
                ]
              ]
            ]
          ]);
    }
    var match$1 = layer[/* children */3];
    var paddingVariables;
    if (match$1) {
      var createVariable$1 = function (paddingParameter) {
        return /* VariableDeclaration */Block.__(8, [{
                    modifiers: /* :: */[
                      /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                      /* [] */0
                    ],
                    pattern: /* IdentifierPattern */Block.__(0, [{
                          identifier: /* SwiftIdentifier */Block.__(6, [variableName(paddingParameter[/* swiftName */1])]),
                          annotation: /* Some */[/* TypeName */Block.__(0, ["CGFloat"])]
                        }]),
                    init: /* Some */[/* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [Layer$LonaCompilerCore.getNumberParameter(paddingParameter[/* lonaName */0], layer)])])],
                    block: /* None */0
                  }]);
      };
      paddingVariables = List.map(createVariable$1, /* :: */[
            /* record */[
              /* lonaName */"paddingTop",
              /* swiftName */"topPadding"
            ],
            /* :: */[
              /* record */[
                /* lonaName */"paddingRight",
                /* swiftName */"trailingPadding"
              ],
              /* :: */[
                /* record */[
                  /* lonaName */"paddingBottom",
                  /* swiftName */"bottomPadding"
                ],
                /* :: */[
                  /* record */[
                    /* lonaName */"paddingLeft",
                    /* swiftName */"leadingPadding"
                  ],
                  /* [] */0
                ]
              ]
            ]
          ]);
    } else {
      paddingVariables = /* [] */0;
    }
    return Pervasives.$at(marginVariables, paddingVariables);
  };
  var initParameterDoc = function (parameter) {
    return /* Parameter */Block.__(14, [{
                externalName: /* None */0,
                localName: parameter[/* name */0],
                annotation: typeAnnotationDoc(parameter[/* ltype */1]),
                defaultValue: /* None */0
              }]);
  };
  var initParameterAssignmentDoc = function (parameter) {
    return /* BinaryExpression */Block.__(2, [{
                left: /* MemberExpression */Block.__(1, [/* :: */[
                      /* SwiftIdentifier */Block.__(6, ["self"]),
                      /* :: */[
                        /* SwiftIdentifier */Block.__(6, [parameter[/* name */0]]),
                        /* [] */0
                      ]
                    ]]),
                operator: "=",
                right: /* SwiftIdentifier */Block.__(6, [parameter[/* name */0]])
              }]);
  };
  var initializerCoderDoc = function () {
    return /* InitializerDeclaration */Block.__(9, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PublicModifier */3]),
                  /* :: */[
                    /* RequiredModifier */10,
                    /* [] */0
                  ]
                ],
                parameters: /* :: */[
                  /* Parameter */Block.__(14, [{
                        externalName: /* Some */["coder"],
                        localName: "aDecoder",
                        annotation: /* TypeName */Block.__(0, ["NSCoder"]),
                        defaultValue: /* None */0
                      }]),
                  /* [] */0
                ],
                failable: /* Some */["?"],
                body: /* :: */[
                  /* FunctionCallExpression */Block.__(16, [{
                        name: /* SwiftIdentifier */Block.__(6, ["fatalError"]),
                        arguments: /* :: */[
                          /* FunctionCallArgument */Block.__(15, [{
                                name: /* None */0,
                                value: /* SwiftIdentifier */Block.__(6, ["\"init(coder:) has not been implemented\""])
                              }]),
                          /* [] */0
                        ]
                      }]),
                  /* [] */0
                ]
              }]);
  };
  var initializerDoc = function () {
    return /* InitializerDeclaration */Block.__(9, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PublicModifier */3]),
                  /* [] */0
                ],
                parameters: List.map(initParameterDoc, parameters),
                failable: /* None */0,
                body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                      List.map(initParameterAssignmentDoc, parameters),
                      /* :: */[
                        /* :: */[
                          /* MemberExpression */Block.__(1, [/* :: */[
                                /* SwiftIdentifier */Block.__(6, ["super"]),
                                /* :: */[
                                  /* FunctionCallExpression */Block.__(16, [{
                                        name: /* SwiftIdentifier */Block.__(6, ["init"]),
                                        arguments: /* :: */[
                                          /* FunctionCallArgument */Block.__(15, [{
                                                name: /* Some */[/* SwiftIdentifier */Block.__(6, ["frame"])],
                                                value: /* SwiftIdentifier */Block.__(6, [".zero"])
                                              }]),
                                          /* [] */0
                                        ]
                                      }]),
                                  /* [] */0
                                ]
                              ]]),
                          /* [] */0
                        ],
                        /* :: */[
                          /* :: */[
                            /* FunctionCallExpression */Block.__(16, [{
                                  name: /* SwiftIdentifier */Block.__(6, ["setUpViews"]),
                                  arguments: /* [] */0
                                }]),
                            /* :: */[
                              /* FunctionCallExpression */Block.__(16, [{
                                    name: /* SwiftIdentifier */Block.__(6, ["setUpConstraints"]),
                                    arguments: /* [] */0
                                  }]),
                              /* [] */0
                            ]
                          ],
                          /* :: */[
                            /* :: */[
                              /* FunctionCallExpression */Block.__(16, [{
                                    name: /* SwiftIdentifier */Block.__(6, ["update"]),
                                    arguments: /* [] */0
                                  }]),
                              /* [] */0
                            ],
                            /* [] */0
                          ]
                        ]
                      ]
                    ])
              }]);
  };
  var memberOrSelfExpression = function (firstIdentifier, statements) {
    if (firstIdentifier === "self") {
      return /* MemberExpression */Block.__(1, [statements]);
    } else {
      return /* MemberExpression */Block.__(1, [Pervasives.$at(/* :: */[
                      /* SwiftIdentifier */Block.__(6, [firstIdentifier]),
                      /* [] */0
                    ], statements)]);
    }
  };
  var parentNameOrSelf = function (parent) {
    var match = +(parent === rootLayer);
    if (match !== 0) {
      return "self";
    } else {
      return SwiftFormat$LonaCompilerCore.layerName(parent[/* name */1]);
    }
  };
  var defineInitialLayerValue = function (layer, param) {
    var name = param[0];
    var parameters = Layer$LonaCompilerCore.LayerMap[/* find_opt */24](layer, layerParameterAssignments);
    if (parameters) {
      var assignment = StringMap$LonaCompilerCore.find_opt(name, parameters[0]);
      var logic = assignment ? assignment[0] : Logic$LonaCompilerCore.defaultAssignmentForLayerParameter(colors, textStyles, layer, name);
      var node = SwiftLogic$LonaCompilerCore.toSwiftAST(swiftOptions, colors, textStyles, rootLayer, logic);
      return /* StatementListHelper */Block.__(21, [node]);
    } else {
      return /* LineComment */Block.__(17, [layer[/* name */1]]);
    }
  };
  var setUpViewsDoc = function (root) {
    var setUpDefaultsDoc = function () {
      var filterParameters = function (param) {
        var name = param[0];
        if (name !== "flexDirection" && name !== "justifyContent" && name !== "alignSelf" && name !== "alignItems" && name !== "flex" && !name.startsWith("padding") && !name.startsWith("margin") && name !== "height") {
          return +(name !== "width");
        } else {
          return /* false */0;
        }
      };
      var defineInitialLayerValues = function (layer) {
        return List.map((function (param) {
                      return defineInitialLayerValue(layer, /* tuple */[
                                  param[0],
                                  param[1]
                                ]);
                    }), List.filter((function (param) {
                            var layer$1 = layer;
                            var param$1 = param;
                            var match = Layer$LonaCompilerCore.LayerMap[/* find_opt */24](layer$1, assignments);
                            if (match) {
                              var match$1 = StringMap$LonaCompilerCore.find_opt(param$1[0], match[0]);
                              if (match$1) {
                                return /* false */0;
                              } else {
                                return /* true */1;
                              }
                            } else {
                              return /* true */1;
                            }
                          }))(List.filter(filterParameters)(Curry._1(StringMap$LonaCompilerCore.bindings, layer[/* parameters */2]))));
      };
      return List.concat(List.map(defineInitialLayerValues, Layer$LonaCompilerCore.flatten(rootLayer)));
    };
    var resetViewStyling = function (layer) {
      var match = layer[/* typeName */0];
      if (match !== 1) {
        if (match !== 0) {
          return /* [] */0;
        } else {
          return /* :: */[
                  /* BinaryExpression */Block.__(2, [{
                        left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                              /* SwiftIdentifier */Block.__(6, ["boxType"]),
                              /* [] */0
                            ]),
                        operator: "=",
                        right: /* SwiftIdentifier */Block.__(6, [".custom"])
                      }]),
                  /* :: */[
                    /* BinaryExpression */Block.__(2, [{
                          left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                                /* SwiftIdentifier */Block.__(6, ["borderType"]),
                                /* [] */0
                              ]),
                          operator: "=",
                          right: /* SwiftIdentifier */Block.__(6, [".noBorder"])
                        }]),
                    /* :: */[
                      /* BinaryExpression */Block.__(2, [{
                            left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                                  /* SwiftIdentifier */Block.__(6, ["contentViewMargins"]),
                                  /* [] */0
                                ]),
                            operator: "=",
                            right: /* SwiftIdentifier */Block.__(6, [".zero"])
                          }]),
                      /* [] */0
                    ]
                  ]
                ];
        }
      } else {
        return /* :: */[
                /* BinaryExpression */Block.__(2, [{
                      left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                            /* SwiftIdentifier */Block.__(6, ["lineBreakMode"]),
                            /* [] */0
                          ]),
                      operator: "=",
                      right: /* SwiftIdentifier */Block.__(6, [".byWordWrapping"])
                    }]),
                /* [] */0
              ];
      }
    };
    var addSubviews = function (parent, layer) {
      if (parent) {
        return /* :: */[
                /* FunctionCallExpression */Block.__(16, [{
                      name: memberOrSelfExpression(parentNameOrSelf(parent[0]), /* :: */[
                            /* SwiftIdentifier */Block.__(6, ["addSubview"]),
                            /* [] */0
                          ]),
                      arguments: /* :: */[
                        /* SwiftIdentifier */Block.__(6, [SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1])]),
                        /* [] */0
                      ]
                    }]),
                /* [] */0
              ];
      } else {
        return /* [] */0;
      }
    };
    var match = +(swiftOptions[/* framework */0] === /* AppKit */1);
    return /* FunctionDeclaration */Block.__(10, [{
                name: "setUpViews",
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                parameters: /* [] */0,
                result: /* None */0,
                body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                      match !== 0 ? List.concat(Layer$LonaCompilerCore.flatmap(resetViewStyling, root)) : /* [] */0,
                      /* :: */[
                        List.concat(Layer$LonaCompilerCore.flatmapParent(addSubviews, root)),
                        /* :: */[
                          setUpDefaultsDoc(/* () */0),
                          /* [] */0
                        ]
                      ]
                    ])
              }]);
  };
  var generateConstraintWithInitialValue = function (constr, node) {
    if (constr.tag) {
      var statements_000 = /* SwiftIdentifier */Block.__(6, [Constraint$LonaCompilerCore.anchorToString(constr[4])]);
      var statements = /* :: */[
        statements_000,
        /* [] */0
      ];
      var statements_000$1 = /* SwiftIdentifier */Block.__(6, [Constraint$LonaCompilerCore.anchorToString(constr[1])]);
      var statements_001 = /* :: */[
        /* FunctionCallExpression */Block.__(16, [{
              name: /* SwiftIdentifier */Block.__(6, ["constraint"]),
              arguments: /* :: */[
                /* FunctionCallArgument */Block.__(15, [{
                      name: /* Some */[/* SwiftIdentifier */Block.__(6, [Constraint$LonaCompilerCore.cmpToString(constr[2])])],
                      value: memberOrSelfExpression(parentNameOrSelf(constr[3]), statements)
                    }]),
                /* :: */[
                  /* FunctionCallArgument */Block.__(15, [{
                        name: /* Some */[/* SwiftIdentifier */Block.__(6, ["constant"])],
                        value: node
                      }]),
                  /* [] */0
                ]
              ]
            }]),
        /* [] */0
      ];
      var statements$1 = /* :: */[
        statements_000$1,
        statements_001
      ];
      return memberOrSelfExpression(parentNameOrSelf(constr[0]), statements$1);
    } else {
      var statements_000$2 = /* SwiftIdentifier */Block.__(6, [Constraint$LonaCompilerCore.anchorToString(constr[1])]);
      var statements_001$1 = /* :: */[
        /* FunctionCallExpression */Block.__(16, [{
              name: /* SwiftIdentifier */Block.__(6, ["constraint"]),
              arguments: /* :: */[
                /* FunctionCallArgument */Block.__(15, [{
                      name: /* Some */[/* SwiftIdentifier */Block.__(6, ["equalToConstant"])],
                      value: node
                    }]),
                /* [] */0
              ]
            }]),
        /* [] */0
      ];
      var statements$2 = /* :: */[
        statements_000$2,
        statements_001$1
      ];
      return memberOrSelfExpression(parentNameOrSelf(constr[0]), statements$2);
    }
  };
  var generateConstraintWithConstant = function (constr, constant) {
    return generateConstraintWithInitialValue(constr, /* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [constant])]));
  };
  var formatConstraintVariableName = function (constr) {
    var formatAnchorVariableName = function (layer, anchor, suffix) {
      var anchorString = Constraint$LonaCompilerCore.anchorToString(anchor);
      var match = +(layer === rootLayer);
      return (
              match !== 0 ? anchorString : SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + LodashUpperfirst(anchorString)
            ) + suffix;
    };
    if (constr.tag) {
      var match = constr[6];
      var edge1 = constr[1];
      var layer1 = constr[0];
      if (match !== 5) {
        if (match !== 6) {
          return formatAnchorVariableName(layer1, edge1, "Constraint");
        } else {
          return SwiftFormat$LonaCompilerCore.layerName(layer1[/* name */1]) + (LodashUpperfirst(SwiftFormat$LonaCompilerCore.layerName(constr[3][/* name */1])) + (LodashUpperfirst(Constraint$LonaCompilerCore.anchorToString(edge1)) + "SiblingConstraint"));
        }
      } else {
        return formatAnchorVariableName(layer1, edge1, "ParentConstraint");
      }
    } else {
      return formatAnchorVariableName(constr[0], constr[1], "Constraint");
    }
  };
  var getConstraints = function (root) {
    var setUpContraint = function (layer, anchor1, parent, anchor2, relation, value, role) {
      var constr = /* Relation */Block.__(1, [
          layer,
          anchor1,
          relation,
          parent,
          anchor2,
          /* Required */0,
          role
        ]);
      var variableName = formatConstraintVariableName(constr);
      var initialValue = generateConstraintWithInitialValue(constr, value);
      return /* record */[
              /* variableName */variableName,
              /* initialValue */initialValue,
              /* priority */Constraint$LonaCompilerCore.getPriority(constr)
            ];
    };
    var setUpLessThanOrEqualToContraint = function (layer, anchor1, parent, anchor2, value, role) {
      var constr = /* Relation */Block.__(1, [
          layer,
          anchor1,
          /* Leq */2,
          parent,
          anchor2,
          /* Low */1,
          role
        ]);
      var variableName = formatConstraintVariableName(constr);
      var initialValue = generateConstraintWithInitialValue(constr, value);
      return /* record */[
              /* variableName */variableName,
              /* initialValue */initialValue,
              /* priority */Constraint$LonaCompilerCore.getPriority(constr)
            ];
    };
    var setUpDimensionContraint = function (layer, anchor, constant, role) {
      var constr = /* Dimension */Block.__(0, [
          layer,
          anchor,
          /* Required */0,
          role
        ]);
      var variableName = formatConstraintVariableName(constr);
      var initialValue = generateConstraintWithConstant(constr, constant);
      return /* record */[
              /* variableName */variableName,
              /* initialValue */initialValue,
              /* priority */Constraint$LonaCompilerCore.getPriority(constr)
            ];
    };
    var negateNumber = function (expression) {
      return /* PrefixExpression */Block.__(3, [{
                  operator: "-",
                  expression: expression
                }]);
    };
    var constraintConstantExpression = function (layer, variable1, parent, variable2) {
      var variableName = function (layer, variable) {
        var match = +(layer === rootLayer);
        if (match !== 0) {
          return variable;
        } else {
          return SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + LodashUpperfirst(variable);
        }
      };
      return /* BinaryExpression */Block.__(2, [{
                  left: /* SwiftIdentifier */Block.__(6, [variableName(layer, variable1)]),
                  operator: "+",
                  right: /* SwiftIdentifier */Block.__(6, [variableName(parent, variable2)])
                }]);
    };
    var constrainAxes = function (layer) {
      var direction = Layer$LonaCompilerCore.getFlexDirection(layer);
      var isColumn = +(direction === "column");
      var primaryBeforeAnchor = isColumn !== 0 ? /* Top */2 : /* Leading */4;
      var primaryAfterAnchor = isColumn !== 0 ? /* Bottom */3 : /* Trailing */5;
      var secondaryBeforeAnchor = isColumn !== 0 ? /* Leading */4 : /* Top */2;
      var secondaryAfterAnchor = isColumn !== 0 ? /* Trailing */5 : /* Bottom */3;
      var primaryDimensionAnchor = isColumn !== 0 ? /* Height */1 : /* Width */0;
      var secondaryDimensionAnchor = isColumn !== 0 ? /* Width */0 : /* Height */1;
      var height = Layer$LonaCompilerCore.getNumberParameterOpt("height", layer);
      var width = Layer$LonaCompilerCore.getNumberParameterOpt("width", layer);
      var sizingRules = Layer$LonaCompilerCore.getSizingRules(Layer$LonaCompilerCore.findParent(rootLayer, layer), layer);
      var primarySizingRule = isColumn !== 0 ? sizingRules[/* height */1] : sizingRules[/* width */0];
      var secondarySizingRule = isColumn !== 0 ? sizingRules[/* width */0] : sizingRules[/* height */1];
      var flexChildren = List.filter((function (child) {
                return +(Layer$LonaCompilerCore.getNumberParameter("flex", child) === 1.0);
              }))(layer[/* children */3]);
      var addConstraints = function (index, child) {
        var childSizingRules = Layer$LonaCompilerCore.getSizingRules(/* Some */[layer], child);
        var childSecondarySizingRule = isColumn !== 0 ? childSizingRules[/* width */0] : childSizingRules[/* height */1];
        var firstViewConstraints;
        if (index !== 0) {
          firstViewConstraints = /* [] */0;
        } else {
          var primaryBeforeConstant = isColumn !== 0 ? constraintConstantExpression(layer, "topPadding", child, "topMargin") : constraintConstantExpression(layer, "leadingPadding", child, "leadingMargin");
          firstViewConstraints = /* :: */[
            setUpContraint(child, primaryBeforeAnchor, layer, primaryBeforeAnchor, /* Eq */0, primaryBeforeConstant, /* PrimaryBefore */0),
            /* [] */0
          ];
        }
        var lastViewConstraints;
        if (index === (List.length(layer[/* children */3]) - 1 | 0)) {
          var match = List.length(flexChildren);
          var needsPrimaryAfterConstraint = typeof primarySizingRule === "number" ? (
              primarySizingRule !== 0 || match ? /* true */1 : /* false */0
            ) : (
              match ? /* true */1 : /* false */0
            );
          var primaryAfterConstant = isColumn !== 0 ? constraintConstantExpression(layer, "bottomPadding", child, "bottomMargin") : constraintConstantExpression(layer, "trailingPadding", child, "trailingMargin");
          lastViewConstraints = needsPrimaryAfterConstraint !== 0 ? /* :: */[
              setUpContraint(child, primaryAfterAnchor, layer, primaryAfterAnchor, /* Eq */0, negateNumber(primaryAfterConstant), /* PrimaryAfter */2),
              /* [] */0
            ] : /* [] */0;
        } else {
          lastViewConstraints = /* [] */0;
        }
        var middleViewConstraints;
        if (index !== 0) {
          var previousLayer = List.nth(layer[/* children */3], index - 1 | 0);
          var betweenConstant = isColumn !== 0 ? constraintConstantExpression(previousLayer, "bottomMargin", child, "topMargin") : constraintConstantExpression(previousLayer, "trailingMargin", child, "leadingMargin");
          middleViewConstraints = /* :: */[
            setUpContraint(child, primaryBeforeAnchor, previousLayer, primaryAfterAnchor, /* Eq */0, betweenConstant, /* PrimaryBetween */1),
            /* [] */0
          ];
        } else {
          middleViewConstraints = /* [] */0;
        }
        var secondaryBeforeConstant = isColumn !== 0 ? constraintConstantExpression(layer, "leadingPadding", child, "leadingMargin") : constraintConstantExpression(layer, "topPadding", child, "topMargin");
        var secondaryAfterConstant = isColumn !== 0 ? constraintConstantExpression(layer, "trailingPadding", child, "trailingMargin") : constraintConstantExpression(layer, "bottomPadding", child, "bottomMargin");
        var secondaryBeforeConstraint = setUpContraint(child, secondaryBeforeAnchor, layer, secondaryBeforeAnchor, /* Eq */0, secondaryBeforeConstant, /* SecondaryBefore */3);
        var secondaryAfterConstraint;
        var exit = 0;
        if (typeof secondarySizingRule === "number" && !(secondarySizingRule !== 0 || !(typeof childSecondarySizingRule === "number" && childSecondarySizingRule !== 0))) {
          secondaryAfterConstraint = /* :: */[
            setUpContraint(child, secondaryAfterAnchor, layer, secondaryAfterAnchor, /* Leq */2, negateNumber(secondaryAfterConstant), /* SecondaryAfter */4),
            /* [] */0
          ];
        } else {
          exit = 1;
        }
        if (exit === 1) {
          secondaryAfterConstraint = typeof childSecondarySizingRule === "number" ? /* :: */[
              setUpContraint(child, secondaryAfterAnchor, layer, secondaryAfterAnchor, /* Eq */0, negateNumber(secondaryAfterConstant), /* SecondaryAfter */4),
              /* [] */0
            ] : /* [] */0;
        }
        var fitContentSecondaryConstraint = typeof secondarySizingRule === "number" && secondarySizingRule !== 0 ? /* :: */[
            setUpLessThanOrEqualToContraint(child, secondaryDimensionAnchor, layer, secondaryDimensionAnchor, negateNumber(/* BinaryExpression */Block.__(2, [{
                          left: secondaryBeforeConstant,
                          operator: "+",
                          right: secondaryAfterConstant
                        }])), /* FitContentSecondary */5),
            /* [] */0
          ] : /* [] */0;
        return Pervasives.$at(firstViewConstraints, Pervasives.$at(lastViewConstraints, Pervasives.$at(middleViewConstraints, Pervasives.$at(/* :: */[
                                secondaryBeforeConstraint,
                                /* [] */0
                              ], Pervasives.$at(secondaryAfterConstraint, fitContentSecondaryConstraint)))));
      };
      var flexChildrenConstraints;
      if (flexChildren) {
        var rest = flexChildren[1];
        var first = flexChildren[0];
        if (List.length(rest) > 0) {
          flexChildrenConstraints = List.mapi((function (param, param$1) {
                  var anchor = primaryDimensionAnchor;
                  var layer = param$1;
                  return setUpContraint(first, anchor, layer, anchor, /* Eq */0, /* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [0.0])]), /* FlexSibling */6);
                }), rest);
        } else {
          flexChildrenConstraints = /* [] */0;
        }
      } else {
        flexChildrenConstraints = /* [] */0;
      }
      var heightConstraint = height ? /* :: */[
          setUpDimensionContraint(layer, /* Height */1, height[0], isColumn !== 0 ? /* PrimaryDimension */7 : /* SecondaryDimension */8),
          /* [] */0
        ] : /* [] */0;
      var widthConstraint = width ? /* :: */[
          setUpDimensionContraint(layer, /* Width */0, width[0], isColumn !== 0 ? /* SecondaryDimension */8 : /* PrimaryDimension */7),
          /* [] */0
        ] : /* [] */0;
      return List.concat(Pervasives.$at(/* :: */[
                      heightConstraint,
                      /* :: */[
                        widthConstraint,
                        /* [] */0
                      ]
                    ], Pervasives.$at(/* :: */[
                          flexChildrenConstraints,
                          /* [] */0
                        ], List.mapi(addConstraints, layer[/* children */3]))));
    };
    return List.concat(Layer$LonaCompilerCore.flatmap(constrainAxes, root));
  };
  var constraints = getConstraints(rootLayer);
  var setUpConstraintsDoc = function (root) {
    var translatesAutoresizingMask = function (layer) {
      return /* BinaryExpression */Block.__(2, [{
                  left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                        /* SwiftIdentifier */Block.__(6, ["translatesAutoresizingMaskIntoConstraints"]),
                        /* [] */0
                      ]),
                  operator: "=",
                  right: /* LiteralExpression */Block.__(0, [/* Boolean */Block.__(0, [/* false */0])])
                }]);
    };
    var defineConstraint = function (def) {
      return /* ConstantDeclaration */Block.__(7, [{
                  modifiers: /* [] */0,
                  init: /* Some */[def[/* initialValue */1]],
                  pattern: /* IdentifierPattern */Block.__(0, [{
                        identifier: /* SwiftIdentifier */Block.__(6, [def[/* variableName */0]]),
                        annotation: /* None */0
                      }])
                }]);
    };
    var setConstraintPriority = function (def) {
      return /* BinaryExpression */Block.__(2, [{
                  left: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(6, [def[/* variableName */0]]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(6, ["priority"]),
                          /* [] */0
                        ]
                      ]]),
                  operator: "=",
                  right: /* MemberExpression */Block.__(1, [/* :: */[
                        SwiftDocument$LonaCompilerCore.layoutPriorityTypeDoc(swiftOptions[/* framework */0]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(6, [priorityName(def[/* priority */2])]),
                          /* [] */0
                        ]
                      ]])
                }]);
    };
    var activateConstraints = function () {
      return /* FunctionCallExpression */Block.__(16, [{
                  name: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(6, ["NSLayoutConstraint"]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(6, ["activate"]),
                          /* [] */0
                        ]
                      ]]),
                  arguments: /* :: */[
                    /* FunctionCallArgument */Block.__(15, [{
                          name: /* None */0,
                          value: /* LiteralExpression */Block.__(0, [/* Array */Block.__(5, [List.map((function (def) {
                                          return /* SwiftIdentifier */Block.__(6, [def[/* variableName */0]]);
                                        }), constraints)])])
                        }]),
                    /* [] */0
                  ]
                }]);
    };
    var assignConstraint = function (def) {
      return /* BinaryExpression */Block.__(2, [{
                  left: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(6, ["self"]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(6, [def[/* variableName */0]]),
                          /* [] */0
                        ]
                      ]]),
                  operator: "=",
                  right: /* SwiftIdentifier */Block.__(6, [def[/* variableName */0]])
                }]);
    };
    var assignConstraintIdentifier = function (def) {
      return /* BinaryExpression */Block.__(2, [{
                  left: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(6, [def[/* variableName */0]]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(6, ["identifier"]),
                          /* [] */0
                        ]
                      ]]),
                  operator: "=",
                  right: /* LiteralExpression */Block.__(0, [/* String */Block.__(3, [def[/* variableName */0]])])
                }]);
    };
    return /* FunctionDeclaration */Block.__(10, [{
                name: "setUpConstraints",
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                parameters: /* [] */0,
                result: /* None */0,
                body: List.concat(/* :: */[
                      Layer$LonaCompilerCore.flatmap(translatesAutoresizingMask, root),
                      /* :: */[
                        /* :: */[
                          /* Empty */0,
                          /* [] */0
                        ],
                        /* :: */[
                          List.map(defineConstraint, constraints),
                          /* :: */[
                            List.map(setConstraintPriority, List.filter((function (def) {
                                          return +(def[/* priority */2] === /* Low */1);
                                        }))(constraints)),
                            /* :: */[
                              /* :: */[
                                /* Empty */0,
                                /* [] */0
                              ],
                              /* :: */[
                                /* :: */[
                                  activateConstraints(/* () */0),
                                  /* [] */0
                                ],
                                /* :: */[
                                  /* :: */[
                                    /* Empty */0,
                                    /* [] */0
                                  ],
                                  /* :: */[
                                    List.map(assignConstraint, constraints),
                                    /* :: */[
                                      /* :: */[
                                        /* Empty */0,
                                        /* :: */[
                                          /* LineComment */Block.__(17, ["For debugging"]),
                                          /* [] */0
                                        ]
                                      ],
                                      /* :: */[
                                        List.map(assignConstraintIdentifier, constraints),
                                        /* [] */0
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ])
              }]);
  };
  var updateDoc = function () {
    var filterParameters = function (param) {
      var name = param[0];
      if (name.includes("margin")) {
        return /* false */0;
      } else {
        return 1 - +name.includes("padding");
      }
    };
    var conditionallyAssigned = Logic$LonaCompilerCore.conditionallyAssignedIdentifiers(logic$1);
    var defineInitialLayerValues = function (param) {
      var layer = param[0];
      return List.map((function (param) {
                    return defineInitialLayerValue(layer, param);
                  }), List.filter((function (param) {
                          var layer$1 = layer;
                          var param$1 = param;
                          var name = param$1[0];
                          var isAssigned = function (param) {
                            return Caml_obj.caml_equal(param[1], /* :: */[
                                        "layers",
                                        /* :: */[
                                          layer$1[/* name */1],
                                          /* :: */[
                                            name,
                                            /* [] */0
                                          ]
                                        ]
                                      ]);
                          };
                          return Curry._2(Logic$LonaCompilerCore.IdentifierSet[/* exists */15], isAssigned, conditionallyAssigned);
                        }))(List.filter(filterParameters)(Curry._1(StringMap$LonaCompilerCore.bindings, param[1]))));
    };
    return /* FunctionDeclaration */Block.__(10, [{
                name: "update",
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                parameters: /* [] */0,
                result: /* None */0,
                body: Pervasives.$at(List.concat(List.map(defineInitialLayerValues, Curry._1(Layer$LonaCompilerCore.LayerMap[/* bindings */16], assignments))), SwiftLogic$LonaCompilerCore.toSwiftAST(swiftOptions, colors, textStyles, rootLayer, logic$1))
              }]);
  };
  var textLayers = List.filter((function (layer) {
            return +(layer[/* typeName */0] === /* Text */1);
          }))(nonRootLayers);
  var match = +(List.length(parameters) > 0);
  return /* TopLevelDeclaration */Block.__(22, [{
              statements: /* :: */[
                SwiftDocument$LonaCompilerCore.importFramework(swiftOptions[/* framework */0]),
                /* :: */[
                  /* ImportDeclaration */Block.__(11, ["Foundation"]),
                  /* :: */[
                    /* Empty */0,
                    /* :: */[
                      /* LineComment */Block.__(17, ["MARK: - " + name]),
                      /* :: */[
                        /* Empty */0,
                        /* :: */[
                          /* ClassDeclaration */Block.__(4, [{
                                name: name,
                                inherits: /* :: */[
                                  /* TypeName */Block.__(0, [getLayerTypeName(/* View */0)]),
                                  /* [] */0
                                ],
                                modifier: /* Some */[/* PublicModifier */3],
                                isFinal: /* false */0,
                                body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                                      /* :: */[
                                        /* Empty */0,
                                        /* :: */[
                                          /* LineComment */Block.__(17, ["MARK: Lifecycle"]),
                                          /* [] */0
                                        ]
                                      ],
                                      /* :: */[
                                        /* :: */[
                                          initializerDoc(/* () */0),
                                          /* [] */0
                                        ],
                                        /* :: */[
                                          /* :: */[
                                            initializerCoderDoc(/* () */0),
                                            /* [] */0
                                          ],
                                          /* :: */[
                                            match !== 0 ? /* :: */[
                                                /* LineComment */Block.__(17, ["MARK: Public"]),
                                                /* [] */0
                                              ] : /* [] */0,
                                            /* :: */[
                                              List.map(parameterVariableDoc, parameters),
                                              /* :: */[
                                                /* :: */[
                                                  /* LineComment */Block.__(17, ["MARK: Private"]),
                                                  /* [] */0
                                                ],
                                                /* :: */[
                                                  List.map(viewVariableDoc, nonRootLayers),
                                                  /* :: */[
                                                    List.map(textStyleVariableDoc, textLayers),
                                                    /* :: */[
                                                      List.concat(Layer$LonaCompilerCore.flatmap(spacingVariableDoc, rootLayer)),
                                                      /* :: */[
                                                        List.map((function (def) {
                                                                var variableName = def[/* variableName */0];
                                                                return /* VariableDeclaration */Block.__(8, [{
                                                                            modifiers: /* :: */[
                                                                              /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                                                                              /* [] */0
                                                                            ],
                                                                            pattern: /* IdentifierPattern */Block.__(0, [{
                                                                                  identifier: /* SwiftIdentifier */Block.__(6, [variableName]),
                                                                                  annotation: /* Some */[/* OptionalType */Block.__(4, [/* TypeName */Block.__(0, ["NSLayoutConstraint"])])]
                                                                                }]),
                                                                            init: /* None */0,
                                                                            block: /* None */0
                                                                          }]);
                                                              }), constraints),
                                                        /* :: */[
                                                          /* :: */[
                                                            setUpViewsDoc(rootLayer),
                                                            /* [] */0
                                                          ],
                                                          /* :: */[
                                                            /* :: */[
                                                              setUpConstraintsDoc(rootLayer),
                                                              /* [] */0
                                                            ],
                                                            /* :: */[
                                                              /* :: */[
                                                                updateDoc(/* () */0),
                                                                /* [] */0
                                                              ],
                                                              /* [] */0
                                                            ]
                                                          ]
                                                        ]
                                                      ]
                                                    ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                      ]
                                    ])
                              }]),
                          /* :: */[
                            /* Empty */0,
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            }]);
}

var Format = 0;

var Ast = 0;

var Document = 0;

var Render = 0;

exports.Format   = Format;
exports.Ast      = Ast;
exports.Document = Document;
exports.Render   = Render;
exports.generate = generate;
/* lodash.upperfirst Not a pure module */
