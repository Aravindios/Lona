// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map                   = require("bs-platform/lib/js/map.js");
var List                    = require("bs-platform/lib/js/list.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Layer$LonaCompilerCore  = require("../core/layer.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function anchorToString(param) {
  switch (param) {
    case 0 : 
        return "widthAnchor";
    case 1 : 
        return "heightAnchor";
    case 2 : 
        return "topAnchor";
    case 3 : 
        return "bottomAnchor";
    case 4 : 
        return "leadingAnchor";
    case 5 : 
        return "trailingAnchor";
    
  }
}

function anchorFromString(param) {
  switch (param) {
    case "bottomAnchor" : 
        return /* Bottom */3;
    case "heightAnchor" : 
        return /* Height */1;
    case "leadingAnchor" : 
        return /* Leading */4;
    case "topAnchor" : 
        return /* Top */2;
    case "trailingAnchor" : 
        return /* Trailing */5;
    case "widthAnchor" : 
        return /* Width */0;
    default:
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/devinabbott/Projects/Lona/compiler/core/src/utils/constraint.re",
              51,
              2
            ]
          ];
  }
}

function cmpFromString(param) {
  switch (param) {
    case "equalTo" : 
        return /* Eq */0;
    case "greaterThanOrEqualTo" : 
        return /* Geq */1;
    case "lessThanOrEqualTo" : 
        return /* Leq */2;
    default:
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/devinabbott/Projects/Lona/compiler/core/src/utils/constraint.re",
              60,
              2
            ]
          ];
  }
}

function cmpToString(param) {
  switch (param) {
    case 0 : 
        return "equalTo";
    case 1 : 
        return "greaterThanOrEqualTo";
    case 2 : 
        return "lessThanOrEqualTo";
    
  }
}

function getPriority(param) {
  if (param.tag) {
    return param[5];
  } else {
    return param[2];
  }
}

function getRole(param) {
  if (param.tag) {
    return param[6];
  } else {
    return param[3];
  }
}

function compare(a, b) {
  if (a.tag) {
    if (b.tag) {
      return Caml_obj.caml_compare(/* tuple */[
                  a[0][/* name */1],
                  a[1],
                  a[3][/* name */1],
                  a[4]
                ], /* tuple */[
                  b[0][/* name */1],
                  b[1],
                  b[3][/* name */1],
                  b[4]
                ]);
    } else {
      return -1;
    }
  } else if (b.tag) {
    return 1;
  } else {
    return Caml_obj.caml_compare(/* tuple */[
                a[0][/* name */1],
                a[1]
              ], /* tuple */[
                b[0][/* name */1],
                b[1]
              ]);
  }
}

var include = $$Map.Make(/* module */[/* compare */compare]);

var find = include[21];

function find_opt(key, map) {
  var exit = 0;
  var item;
  try {
    item = Curry._2(find, key, map);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return /* Some */[item];
  }
  
}

var ConstraintMap_000 = /* empty */include[0];

var ConstraintMap_001 = /* is_empty */include[1];

var ConstraintMap_002 = /* mem */include[2];

var ConstraintMap_003 = /* add */include[3];

var ConstraintMap_004 = /* singleton */include[4];

var ConstraintMap_005 = /* remove */include[5];

var ConstraintMap_006 = /* merge */include[6];

var ConstraintMap_007 = /* compare */include[7];

var ConstraintMap_008 = /* equal */include[8];

var ConstraintMap_009 = /* iter */include[9];

var ConstraintMap_010 = /* fold */include[10];

var ConstraintMap_011 = /* for_all */include[11];

var ConstraintMap_012 = /* exists */include[12];

var ConstraintMap_013 = /* filter */include[13];

var ConstraintMap_014 = /* partition */include[14];

var ConstraintMap_015 = /* cardinal */include[15];

var ConstraintMap_016 = /* bindings */include[16];

var ConstraintMap_017 = /* min_binding */include[17];

var ConstraintMap_018 = /* max_binding */include[18];

var ConstraintMap_019 = /* choose */include[19];

var ConstraintMap_020 = /* split */include[20];

var ConstraintMap_022 = /* map */include[22];

var ConstraintMap_023 = /* mapi */include[23];

var ConstraintMap = /* module */[
  ConstraintMap_000,
  ConstraintMap_001,
  ConstraintMap_002,
  ConstraintMap_003,
  ConstraintMap_004,
  ConstraintMap_005,
  ConstraintMap_006,
  ConstraintMap_007,
  ConstraintMap_008,
  ConstraintMap_009,
  ConstraintMap_010,
  ConstraintMap_011,
  ConstraintMap_012,
  ConstraintMap_013,
  ConstraintMap_014,
  ConstraintMap_015,
  ConstraintMap_016,
  ConstraintMap_017,
  ConstraintMap_018,
  ConstraintMap_019,
  ConstraintMap_020,
  /* find */find,
  ConstraintMap_022,
  ConstraintMap_023,
  /* find_opt */find_opt
];

function getConstraints(rootLayer) {
  var constrainAxes = function (layer) {
    var direction = Layer$LonaCompilerCore.getFlexDirection(layer);
    var isColumn = +(direction === "column");
    var primaryBeforeAnchor = isColumn !== 0 ? /* Top */2 : /* Leading */4;
    var primaryAfterAnchor = isColumn !== 0 ? /* Bottom */3 : /* Trailing */5;
    var secondaryBeforeAnchor = isColumn !== 0 ? /* Leading */4 : /* Top */2;
    var secondaryAfterAnchor = isColumn !== 0 ? /* Trailing */5 : /* Bottom */3;
    var primaryDimensionAnchor = isColumn !== 0 ? /* Height */1 : /* Width */0;
    var secondaryDimensionAnchor = isColumn !== 0 ? /* Width */0 : /* Height */1;
    var height = Layer$LonaCompilerCore.getNumberParameterOpt("height", layer);
    var width = Layer$LonaCompilerCore.getNumberParameterOpt("width", layer);
    var sizingRules = Layer$LonaCompilerCore.getSizingRules(Layer$LonaCompilerCore.findParent(rootLayer, layer), layer);
    var primarySizingRule = isColumn !== 0 ? sizingRules[/* height */1] : sizingRules[/* width */0];
    var secondarySizingRule = isColumn !== 0 ? sizingRules[/* width */0] : sizingRules[/* height */1];
    var flexChildren = List.filter((function (child) {
              return +(Layer$LonaCompilerCore.getNumberParameter("flex", child) === 1.0);
            }))(layer[/* children */3]);
    var addConstraints = function (index, child) {
      var childSizingRules = Layer$LonaCompilerCore.getSizingRules(/* Some */[layer], child);
      var childSecondarySizingRule = isColumn !== 0 ? childSizingRules[/* width */0] : childSizingRules[/* height */1];
      var firstViewConstraints = index !== 0 ? /* [] */0 : /* :: */[
          /* Relation */Block.__(1, [
              child,
              primaryBeforeAnchor,
              /* Eq */0,
              layer,
              primaryBeforeAnchor,
              /* Required */0,
              /* PrimaryBefore */0
            ]),
          /* [] */0
        ];
      var lastViewConstraints;
      if (index === (List.length(layer[/* children */3]) - 1 | 0)) {
        var match = List.length(flexChildren);
        var needsPrimaryAfterConstraint = typeof primarySizingRule === "number" ? (
            primarySizingRule !== 0 || match ? /* true */1 : /* false */0
          ) : (
            match ? /* true */1 : /* false */0
          );
        lastViewConstraints = needsPrimaryAfterConstraint !== 0 ? /* :: */[
            /* Relation */Block.__(1, [
                child,
                primaryAfterAnchor,
                /* Eq */0,
                layer,
                primaryAfterAnchor,
                /* Required */0,
                /* PrimaryAfter */2
              ]),
            /* [] */0
          ] : /* [] */0;
      } else {
        lastViewConstraints = /* [] */0;
      }
      var middleViewConstraints;
      if (index !== 0) {
        var previousLayer = List.nth(layer[/* children */3], index - 1 | 0);
        middleViewConstraints = /* :: */[
          /* Relation */Block.__(1, [
              child,
              primaryBeforeAnchor,
              /* Eq */0,
              previousLayer,
              primaryAfterAnchor,
              /* Required */0,
              /* PrimaryBetween */1
            ]),
          /* [] */0
        ];
      } else {
        middleViewConstraints = /* [] */0;
      }
      var secondaryBeforeConstraint = /* Relation */Block.__(1, [
          child,
          secondaryBeforeAnchor,
          /* Eq */0,
          layer,
          secondaryBeforeAnchor,
          /* Required */0,
          /* SecondaryBefore */3
        ]);
      var secondaryAfterConstraint;
      var exit = 0;
      if (typeof secondarySizingRule === "number" && !(secondarySizingRule !== 0 || !(typeof childSecondarySizingRule === "number" && childSecondarySizingRule !== 0))) {
        secondaryAfterConstraint = /* :: */[
          /* Relation */Block.__(1, [
              child,
              secondaryAfterAnchor,
              /* Leq */2,
              layer,
              secondaryAfterAnchor,
              /* Required */0,
              /* SecondaryAfter */4
            ]),
          /* [] */0
        ];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        secondaryAfterConstraint = typeof childSecondarySizingRule === "number" ? /* :: */[
            /* Relation */Block.__(1, [
                child,
                secondaryAfterAnchor,
                /* Eq */0,
                layer,
                secondaryAfterAnchor,
                /* Required */0,
                /* SecondaryAfter */4
              ]),
            /* [] */0
          ] : /* [] */0;
      }
      var fitContentSecondaryConstraint = typeof secondarySizingRule === "number" && secondarySizingRule !== 0 ? /* :: */[
          /* Relation */Block.__(1, [
              child,
              secondaryDimensionAnchor,
              /* Leq */2,
              layer,
              secondaryDimensionAnchor,
              /* Low */1,
              /* FitContentSecondary */5
            ]),
          /* [] */0
        ] : /* [] */0;
      return Pervasives.$at(firstViewConstraints, Pervasives.$at(lastViewConstraints, Pervasives.$at(middleViewConstraints, Pervasives.$at(/* :: */[
                              secondaryBeforeConstraint,
                              /* [] */0
                            ], Pervasives.$at(secondaryAfterConstraint, fitContentSecondaryConstraint)))));
    };
    var flexChildrenConstraints;
    if (flexChildren) {
      var rest = flexChildren[1];
      var first = flexChildren[0];
      if (List.length(rest) > 0) {
        flexChildrenConstraints = List.map((function (param) {
                var anchor = primaryDimensionAnchor;
                var layer = param;
                return /* Relation */Block.__(1, [
                          first,
                          anchor,
                          /* Eq */0,
                          layer,
                          anchor,
                          /* Required */0,
                          /* FlexSibling */6
                        ]);
              }), rest);
      } else {
        flexChildrenConstraints = /* [] */0;
      }
    } else {
      flexChildrenConstraints = /* [] */0;
    }
    var heightConstraint = height ? /* :: */[
        /* Dimension */Block.__(0, [
            layer,
            /* Height */1,
            /* Required */0,
            isColumn !== 0 ? /* PrimaryDimension */7 : /* SecondaryDimension */8
          ]),
        /* [] */0
      ] : /* [] */0;
    var widthConstraint = width ? /* :: */[
        /* Dimension */Block.__(0, [
            layer,
            /* Width */0,
            /* Required */0,
            isColumn !== 0 ? /* SecondaryDimension */8 : /* PrimaryDimension */7
          ]),
        /* [] */0
      ] : /* [] */0;
    return List.concat(Pervasives.$at(/* :: */[
                    heightConstraint,
                    /* :: */[
                      widthConstraint,
                      /* [] */0
                    ]
                  ], Pervasives.$at(/* :: */[
                        flexChildrenConstraints,
                        /* [] */0
                      ], List.mapi(addConstraints, layer[/* children */3]))));
  };
  return List.concat(Layer$LonaCompilerCore.flatmap(constrainAxes, rootLayer));
}

exports.anchorToString   = anchorToString;
exports.anchorFromString = anchorFromString;
exports.cmpFromString    = cmpFromString;
exports.cmpToString      = cmpToString;
exports.getPriority      = getPriority;
exports.getRole          = getRole;
exports.ConstraintMap    = ConstraintMap;
exports.getConstraints   = getConstraints;
/* include Not a pure module */
