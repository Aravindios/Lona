// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Set                   = require("bs-platform/lib/js/set.js");
var List                    = require("bs-platform/lib/js/list.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Tree$LonaCompilerCore   = require("../containers/tree.bs.js");
var Render$LonaCompilerCore = require("./render.bs.js");

function compare(a, b) {
  return Caml_string.caml_string_compare(Render$LonaCompilerCore.$$String[/* join */0]("", a[1]), Render$LonaCompilerCore.$$String[/* join */0]("", b[1]));
}

var include = $$Set.Make(/* module */[/* compare */compare]);

var empty = include[0];

var add = include[3];

var elements = include[19];

var IdentifierSet_001 = /* is_empty */include[1];

var IdentifierSet_002 = /* mem */include[2];

var IdentifierSet_004 = /* singleton */include[4];

var IdentifierSet_005 = /* remove */include[5];

var IdentifierSet_006 = /* union */include[6];

var IdentifierSet_007 = /* inter */include[7];

var IdentifierSet_008 = /* diff */include[8];

var IdentifierSet_009 = /* compare */include[9];

var IdentifierSet_010 = /* equal */include[10];

var IdentifierSet_011 = /* subset */include[11];

var IdentifierSet_012 = /* iter */include[12];

var IdentifierSet_013 = /* fold */include[13];

var IdentifierSet_014 = /* for_all */include[14];

var IdentifierSet_015 = /* exists */include[15];

var IdentifierSet_016 = /* filter */include[16];

var IdentifierSet_017 = /* partition */include[17];

var IdentifierSet_018 = /* cardinal */include[18];

var IdentifierSet_020 = /* min_elt */include[20];

var IdentifierSet_021 = /* max_elt */include[21];

var IdentifierSet_022 = /* choose */include[22];

var IdentifierSet_023 = /* split */include[23];

var IdentifierSet_024 = /* find */include[24];

var IdentifierSet_025 = /* of_list */include[25];

var IdentifierSet = /* module */[
  /* empty */empty,
  IdentifierSet_001,
  IdentifierSet_002,
  /* add */add,
  IdentifierSet_004,
  IdentifierSet_005,
  IdentifierSet_006,
  IdentifierSet_007,
  IdentifierSet_008,
  IdentifierSet_009,
  IdentifierSet_010,
  IdentifierSet_011,
  IdentifierSet_012,
  IdentifierSet_013,
  IdentifierSet_014,
  IdentifierSet_015,
  IdentifierSet_016,
  IdentifierSet_017,
  IdentifierSet_018,
  /* elements */elements,
  IdentifierSet_020,
  IdentifierSet_021,
  IdentifierSet_022,
  IdentifierSet_023,
  IdentifierSet_024,
  IdentifierSet_025
];

function children(node) {
  if (typeof node === "number") {
    return /* [] */0;
  } else {
    switch (node.tag | 0) {
      case 0 : 
          return /* :: */[
                  node[3],
                  /* [] */0
                ];
      case 1 : 
          return /* :: */[
                  node[1],
                  /* [] */0
                ];
      case 5 : 
          return node[0];
      default:
        return /* [] */0;
    }
  }
}

function restore(node, contents) {
  if (typeof node === "number") {
    return node;
  } else {
    switch (node.tag | 0) {
      case 0 : 
          return /* If */Block.__(0, [
                    node[0],
                    node[1],
                    node[2],
                    List.nth(contents, 0)
                  ]);
      case 1 : 
          return /* IfExists */Block.__(1, [
                    node[0],
                    List.nth(contents, 0)
                  ]);
      case 5 : 
          return /* Block */Block.__(5, [contents]);
      default:
        return node;
    }
  }
}

var LogicTree = Tree$LonaCompilerCore.Make(/* module */[
      /* children */children,
      /* restore */restore
    ]);

function undeclaredIdentifiers(node) {
  var inner = function (node, identifiers) {
    if (typeof node === "number") {
      return identifiers;
    } else if (node.tag === 2) {
      var match = node[1];
      if (typeof match === "number" || match.tag) {
        return identifiers;
      } else {
        return Curry._2(add, /* tuple */[
                    match[0],
                    match[1]
                  ], identifiers);
      }
    } else {
      return identifiers;
    }
  };
  return Curry._3(LogicTree[/* reduce */0], inner, empty, node);
}

function assignedIdentifiers(node) {
  var inner = function (node, identifiers) {
    if (typeof node === "number") {
      return identifiers;
    } else if (node.tag === 2) {
      var match = node[1];
      if (typeof match === "number" || match.tag) {
        return identifiers;
      } else {
        return Curry._2(add, /* tuple */[
                    match[0],
                    match[1]
                  ], identifiers);
      }
    } else {
      return identifiers;
    }
  };
  return Curry._3(LogicTree[/* reduce */0], inner, empty, node);
}

function conditionallyAssignedIdentifiers(rootNode) {
  var identifiers = undeclaredIdentifiers(rootNode);
  var paths = Curry._1(elements, identifiers);
  var isAlwaysAssigned = function (target, _node) {
    while(true) {
      var node = _node;
      if (typeof node === "number") {
        return /* false */0;
      } else {
        switch (node.tag | 0) {
          case 0 : 
              var match = node[2];
              if (typeof match === "number") {
                return /* false */0;
              } else if (match.tag) {
                return /* false */0;
              } else if (Caml_obj.caml_equal(match[1], target)) {
                _node = node[3];
                continue ;
                
              } else {
                return /* false */0;
              }
              break;
          case 2 : 
              var match$1 = node[1];
              if (typeof match$1 === "number" || match$1.tag) {
                return /* false */0;
              } else {
                return Caml_obj.caml_equal(match$1[1], target);
              }
              break;
          case 5 : 
              return List.exists((function (param) {
                            return isAlwaysAssigned(target, param);
                          }), node[0]);
          default:
            return /* false */0;
        }
      }
    };
  };
  var accumulate = function (set, param) {
    var path = param[1];
    var match = isAlwaysAssigned(path, rootNode);
    if (match !== 0) {
      return set;
    } else {
      return Curry._2(add, /* tuple */[
                  param[0],
                  path
                ], set);
    }
  };
  return List.fold_left(accumulate, empty, paths);
}

function addVariableDeclarations(node) {
  var identifiers = undeclaredIdentifiers(node);
  return List.fold_left((function (acc, declaration) {
                return Curry._2(LogicTree[/* insert_child */8], (function (item) {
                              var match = Caml_obj.caml_equal(item, acc);
                              if (match !== 0) {
                                return /* Some */[declaration];
                              } else {
                                return /* None */0;
                              }
                            }), acc);
              }), node, List.map((function (param) {
                    return /* Let */Block.__(4, [/* Identifier */Block.__(0, [
                                  param[0],
                                  param[1]
                                ])]);
                  }), Curry._1(elements, identifiers)));
}

exports.IdentifierSet                    = IdentifierSet;
exports.LogicTree                        = LogicTree;
exports.undeclaredIdentifiers            = undeclaredIdentifiers;
exports.assignedIdentifiers              = assignedIdentifiers;
exports.conditionallyAssignedIdentifiers = conditionallyAssignedIdentifiers;
exports.addVariableDeclarations          = addVariableDeclarations;
/* include Not a pure module */
